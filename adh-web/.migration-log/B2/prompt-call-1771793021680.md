Generate a complete Zustand store for the "fermetureCaisse" domain.

RULES (MANDATORY):
- Use import aliases: @/ for src root (e.g. @/stores/..., @/types/...)
- NEVER use `any` type - use `unknown` or precise types
- Tailwind v4 classes for styling (no tailwind.config.js)
- Arrow functions everywhere (no function declarations)
- `as const` instead of TypeScript enum
- verbatimModuleSyntax is enabled: use `import type { X }` ONLY for types/interfaces, use `import { X }` for values/consts
- File must be COMPLETE and ready to write - NO placeholders, NO TODOs, NO "// implement here"
- NO comments except for genuinely complex logic
- Output ONLY the code inside a single markdown code block (```typescript ... ``` or ```tsx ... ```)

SHARED INFRASTRUCTURE (use these exact imports):
- Data source toggle: `import { useDataSourceStore } from "@/stores/dataSourceStore"` (has .getState().isRealApi)
- API client: `import { apiClient } from "@/services/api/apiClient"` and `import type { ApiResponse } from "@/services/api/apiClient"`
- Screen layout: `import { ScreenLayout } from "@/components/layout"` (wrapper with sidebar, takes children + className)
- UI components: `import { Button, Dialog, Input } from "@/components/ui"`
- cn utility: `import { cn } from "@/lib/utils"`

STORE REQUIREMENTS:
- Use `create` from zustand (import { create } from "zustand")
- Import types from @/types/fermetureCaisse
- Import useDataSourceStore from @/stores/dataSourceStore
- Mock/API branching via useDataSourceStore.getState().isRealApi
- try/catch with `e instanceof Error` for error handling
- Realistic mock data (not lorem ipsum)
- EVERY business rule from the analysis MUST be implemented
- Include reset() action to clear state

TYPES FILE (already generated):
export type FermetureCaisseView = 'recap' | 'saisie' | 'ecart' | 'coffre' | 'validation';

export interface PointageDevise {
  societe: string;
  numeroSession: number;
  codeDevise: string;
  montantOuverture: number;
  montantCompte: number;
  montantCalcule: number;
  ecart: number;
  commentaireEcart: string | null;
}

export interface PointageArticle {
  societe: string;
  numeroSession: number;
  codeArticle: string;
  quantiteOuverture: number;
  quantiteComptee: number;
  quantiteCalculee: number;
  ecart: number;
}

export interface PointageApproRemise {
  societe: string;
  numeroSession: number;
  type: 'APPORT' | 'REMISE';
  montant: number;
  ticketEdite: boolean;
}

export interface MoyenPaiement {
  code: string;
  libelle: string;
  soldeOuverture: number;
  montantCompte: number;
  montantCalcule: number;
  ecart: number;
}

export interface RecapFermeture {
  societe: string;
  numeroSession: number;
  moyensPaiement: MoyenPaiement[];
  totalVersementCoffre: number;
  soldeFinal: number;
}

export interface FermetureCaisseState {
  recapFermeture: RecapFermeture | null;
  pointagesDevise: PointageDevise[];
  pointagesArticle: PointageArticle[];
  pointagesApproRemise: PointageApproRemise[];
  ecartsDetectes: boolean;
  ecartsJustifies: boolean;
  tousPointes: boolean;
  fermetureValidee: boolean;
  isLoading: boolean;
  error: string | null;
  currentView: FermetureCaisseView;

  chargerRecapFermeture: (societe: string, numeroSession: number) => Promise<void>;
  saisirMontantsComptes: (moyenPaiement: string) => Promise<void>;
  calculerEcarts: () => Promise<void>;
  justifierEcart: (moyenPaiement: string, commentaire: string) => Promise<void>;
  effectuerApportCoffre: (montant: number) => Promise<void>;
  effectuerApportArticles: (codeArticle: string, quantite: number) => Promise<void>;
  effectuerRemiseCaisse: (montant: number) => Promise<void>;
  validerFermeture: (societe: string, numeroSession: number) => Promise<void>;
  genererTickets: (societe: string, numeroSession: number) => Promise<void>;
  mettreAJourHistorique: (societe: string, numeroSession: number) => Promise<void>;
  calculerSoldeFinal: () => Promise<void>;
  afficherDetailDevises: () => Promise<void>;
  setCurrentView: (view: FermetureCaisseView) => void;
  reset: () => void;
}

export interface SaisirMontantsRequest {
  societe: string;
  numeroSession: number;
  moyenPaiement: string;
}

export interface JustifierEcartRequest {
  societe: string;
  numeroSession: number;
  moyenPaiement: string;
  commentaire: string;
}

export interface ApportCoffreRequest {
  societe: string;
  numeroSession: number;
  montant: number;
}

export interface ApportArticlesRequest {
  societe: string;
  numeroSession: number;
  codeArticle: string;
  quantite: number;
}

export interface RemiseCaisseRequest {
  societe: string;
  numeroSession: number;
  montant: number;
}

export interface ValiderFermetureRequest {
  societe: string;
  numeroSession: number;
}

export interface ValiderFermetureResponse {
  success: boolean;
  errors?: string[];
}

export interface GenererTicketsResponse {
  tickets: string[];
}

export interface FermetureCaisseApiResponse<T> extends ApiResponse<T> {
  data?: T;
}

ANALYSIS DOCUMENT:
{
  "domain": "fermetureCaisse",
  "domainPascal": "FermetureCaisse",
  "complexity": "HIGH",
  "entities": [
    {
      "name": "PointageDevise",
      "fields": [
        {
          "name": "societe",
          "type": "string",
          "source": "pointage_devise.societe",
          "nullable": false
        },
        {
          "name": "numeroSession",
          "type": "number",
          "source": "pointage_devise.numero_session",
          "nullable": false
        },
        {
          "name": "codeDevise",
          "type": "string",
          "source": "pointage_devise.code_devise",
          "nullable": false
        },
        {
          "name": "montantOuverture",
          "type": "number",
          "source": "pointage_devise.montant_ouverture",
          "nullable": false
        },
        {
          "name": "montantCompte",
          "type": "number",
          "source": "pointage_devise.montant_compte",
          "nullable": false
        },
        {
          "name": "montantCalcule",
          "type": "number",
          "source": "pointage_devise.montant_calcule",
          "nullable": false
        },
        {
          "name": "ecart",
          "type": "number",
          "source": "pointage_devise.ecart",
          "nullable": false
        },
        {
          "name": "commentaireEcart",
          "type": "string",
          "source": "pointage_devise.commentaire_ecart",
          "nullable": true
        }
      ]
    },
    {
      "name": "PointageArticle",
      "fields": [
        {
          "name": "societe",
          "type": "string",
          "source": "pointage_article.societe",
          "nullable": false
        },
        {
          "name": "numeroSession",
          "type": "number",
          "source": "pointage_article.numero_session",
          "nullable": false
        },
        {
          "name": "codeArticle",
          "type": "string",
          "source": "pointage_article.code_article",
          "nullable": false
        },
        {
          "name": "quantiteOuverture",
          "type": "number",
          "source": "pointage_article.quantite_ouverture",
          "nullable": false
        },
        {
          "name": "quantiteComptee",
          "type": "number",
          "source": "pointage_article.quantite_comptee",
          "nullable": false
        },
        {
          "name": "quantiteCalculee",
          "type": "number",
          "source": "pointage_article.quantite_calculee",
          "nullable": false
        },
        {
          "name": "ecart",
          "type": "number",
          "source": "pointage_article.ecart",
          "nullable": false
        }
      ]
    },
    {
      "name": "PointageApproRemise",
      "fields": [
        {
          "name": "societe",
          "type": "string",
          "source": "pointage_appro_remise.societe",
          "nullable": false
        },
        {
          "name": "numeroSession",
          "type": "number",
          "source": "pointage_appro_remise.numero_session",
          "nullable": false
        },
        {
          "name": "type",
          "type": "string",
          "source": "pointage_appro_remise.type",
          "nullable": false
        },
        {
          "name": "montant",
          "type": "number",
          "source": "pointage_appro_remise.montant",
          "nullable": false
        },
        {
          "name": "ticketEdite",
          "type": "boolean",
          "source": "pointage_appro_remise.ticket_edite",
          "nullable": false
        }
      ]
    },
    {
      "name": "MoyenPaiement",
      "fields": [
        {
          "name": "code",
          "type": "string",
          "source": "derived",
          "nullable": false
        },
        {
          "name": "libelle",
          "type": "string",
          "source": "derived",
          "nullable": false
        },
        {
          "name": "soldeOuverture",
          "type": "number",
          "source": "derived",
          "nullable": false
        },
        {
          "name": "montantCompte",
          "type": "number",
          "source": "derived",
          "nullable": false
        },
        {
          "name": "montantCalcule",
          "type": "number",
          "source": "derived",
          "nullable": false
        },
        {
          "name": "ecart",
          "type": "number",
          "source": "derived",
          "nullable": false
        }
      ]
    },
    {
      "name": "RecapFermeture",
      "fields": [
        {
          "name": "societe",
          "type": "string",
          "source": "session.societe",
          "nullable": false
        },
        {
          "name": "numeroSession",
          "type": "number",
          "source": "session.numero_session",
          "nullable": false
        },
        {
          "name": "moyensPaiement",
          "type": "MoyenPaiement[]",
          "source": "derived",
          "nullable": false
        },
        {
          "name": "totalVersementCoffre",
          "type": "number",
          "source": "derived",
          "nullable": false
        },
        {
          "name": "soldeFinal",
          "type": "number",
          "source": "derived",
          "nullable": false
        }
      ]
    }
  ],
  "stateFields": [
    {
      "name": "recapFermeture",
      "type": "RecapFermeture | null",
      "default": "null"
    },
    {
      "name": "pointagesDevise",
      "type": "PointageDevise[]",
      "default": "[]"
    },
    {
      "name": "pointagesArticle",
      "type": "PointageArticle[]",
      "default": "[]"
    },
    {
      "name": "pointagesApproRemise",
      "type": "PointageApproRemise[]",
      "default": "[]"
    },
    {
      "name": "ecartsDetectes",
      "type": "boolean",
      "default": "false"
    },
    {
      "name": "ecartsJustifies",
      "type": "boolean",
      "default": "false"
    },
    {
      "name": "tousPointes",
      "type": "boolean",
      "default": "false"
    },
    {
      "name": "fermetureValidee",
      "type": "boolean",
      "default": "false"
    },
    {
      "name": "isLoading",
      "type": "boolean",
      "default": "false"
    },
    {
      "name": "error",
      "type": "string | null",
      "default": "null"
    },
    {
      "name": "currentView",
      "type": "'recap' | 'saisie' | 'ecart' | 'coffre' | 'validation'",
      "default": "'recap'"
    }
  ],
  "actions": [
    {
      "name": "chargerRecapFermeture",
      "params": [
        "societe: string",
        "numeroSession: number"
      ],
      "businessRules": [
        "Charge le tableau recapitulatif avec 6 colonnes de moyens de paiement (Cash, Cartes, Cheques, Produits, OD, Devises)",
        "Affiche 4 lignes par moyen: Solde ouverture, Montant compte, Montant calcule, Ecart",
        "Calcule automatiquement Ecart = Montant_compte - Montant_calcule pour chaque moyen"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "saisirMontantsComptes",
      "params": [
        "moyenPaiement: string"
      ],
      "businessRules": [
        "Ouvre la saisie des montants comptes pour le moyen de paiement selectionne",
        "Appelle le programme IDE 120 (Saisie contenu caisse)",
        "Met a jour la colonne 'Montant compte' dans le tableau recap"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "calculerEcarts",
      "params": [],
      "businessRules": [
        "Calcule les ecarts pour tous les moyens de paiement: Ecart = Montant_compte - Montant_calcule",
        "Detecte si des ecarts existent (ecart <> 0)",
        "Met a jour l'etat ecartsDetectes"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "justifierEcart",
      "params": [
        "moyenPaiement: string",
        "commentaire: string"
      ],
      "businessRules": [
        "Obligatoire si Ecart <> 0",
        "Appelle le programme IDE 130 (Ecart fermeture caisse)",
        "Enregistre le commentaire de justification dans pointage_devise.commentaire_ecart",
        "Met a jour l'etat ecartsJustifies quand tous les ecarts sont justifies"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "effectuerApportCoffre",
      "params": [
        "montant: number"
      ],
      "businessRules": [
        "Appelle le programme IDE 123 (Apport coffre)",
        "Enregistre le mouvement dans pointage_appro_remise avec type='APPORT'",
        "Recalcule le solde final: Solde_final = Montant_compte - Versement_coffre"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "effectuerApportArticles",
      "params": [
        "codeArticle: string",
        "quantite: number"
      ],
      "businessRules": [
        "Appelle le programme IDE 124 (Apport articles)",
        "Met a jour pointage_article avec les quantites comptees",
        "Recalcule les ecarts sur les produits"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "effectuerRemiseCaisse",
      "params": [
        "montant: number"
      ],
      "businessRules": [
        "Appelle le programme IDE 125 (Remise en caisse)",
        "Enregistre le mouvement dans pointage_appro_remise avec type='REMISE'",
        "Recalcule le solde final"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "validerFermeture",
      "params": [
        "societe: string",
        "numeroSession: number"
      ],
      "businessRules": [
        "Appelle le programme IDE 155 (Controle fermeture caisse WS)",
        "Controle 1: Tous les moyens de paiement ont ete pointes (tousPointes = true)",
        "Controle 2: Tous les ecarts ont ete justifies si des ecarts existent (ecartsJustifies = true si ecartsDetectes)",
        "Bloque la validation si les controles echouent",
        "Met a jour fermetureValidee = true si validation OK"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "genererTickets",
      "params": [
        "societe: string",
        "numeroSession: number"
      ],
      "businessRules": [
        "Appelle IDE 138 pour generer le ticket de fermeture de session",
        "Appelle IDE 136 pour generer les tickets de remises/appros",
        "Appelle IDE 154 pour generer le tableau recap fermeture",
        "Enregistre ticket_edite = true dans pointage_appro_remise",
        "Ne peut s'executer que si fermetureValidee = true"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "mettreAJourHistorique",
      "params": [
        "societe: string",
        "numeroSession: number"
      ],
      "businessRules": [
        "Appelle IDE 134 (MAJ detail session WS) pour mettre a jour l'historique",
        "Met a jour pointage_devise avec les montants finaux et ecarts",
        "Met a jour pointage_article avec les stocks finaux",
        "Met a jour pointage_appro_remise avec les mouvements coffre",
        "Ne peut s'executer que si fermetureValidee = true"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "calculerSoldeFinal",
      "params": [],
      "businessRules": [
        "Calcule Solde_final = SUM(Montant_compte de tous les moyens) - SUM(Versements au coffre)",
        "Met a jour l'etat recapFermeture.soldeFinal"
      ],
      "returns": "Promise<void>"
    },
    {
      "name": "afficherDetailDevises",
      "params": [],
      "businessRules": [
        "Affiche le detail des devises comptees",
        "Permet de consulter les montants par devise",
        "Readonly, pas de modification possible a cette etape"
      ],
      "returns": "Promise<void>"
    }
  ],
  "apiEndpoints": [
    {
      "method": "GET",
      "path": "/api/fermeture-caisse/recap/{societe}/{numeroSession}",
      "queryParams": [],
      "response": "RecapFermeture"
    },
    {
      "method": "GET",
      "path": "/api/fermeture-caisse/pointages-devise/{societe}/{numeroSession}",
      "queryParams": [],
      "response": "PointageDevise[]"
    },
    {
      "method": "GET",
      "path": "/api/fermeture-caisse/pointages-article/{societe}/{numeroSession}",
      "queryParams": [],
      "response": "PointageArticle[]"
    },
    {
      "method": "GET",
      "path": "/api/fermeture-caisse/pointages-appro-remise/{societe}/{numeroSession}",
      "queryParams": [],
      "response": "PointageApproRemise[]"
    },
    {
      "method": "POST",
      "path": "/api/fermeture-caisse/saisir-montants",
      "queryParams": [],
      "response": "void"
    },
    {
      "method": "POST",
      "path": "/api/fermeture-caisse/justifier-ecart",
      "queryParams": [],
      "response": "void"
    },
    {
      "method": "POST",
      "path": "/api/fermeture-caisse/apport-coffre",
      "queryParams": [],
      "response": "void"
    },
    {
      "method": "POST",
      "path": "/api/fermeture-caisse/apport-articles",
      "queryParams": [],
      "response": "void"
    },
    {
      "method": "POST",
      "path": "/api/fermeture-caisse/remise-caisse",
      "queryParams": [],
      "response": "void"
    },
    {
      "method": "POST",
      "path": "/api/fermeture-caisse/valider",
      "queryParams": [],
      "response": "{ success: boolean, errors?: string[] }"
    },
    {
      "method": "POST",
      "path": "/api/fermeture-caisse/generer-tickets",
      "queryParams": [],
      "response": "{ tickets: string[] }"
    },
    {
      "method": "PUT",
      "path": "/api/fermeture-caisse/historique",
      "queryParams": [],
      "response": "void"
    }
  ],
  "uiLayout": {
    "type": "page-with-tabs",
    "sections": [
      {
        "name": "recap",
        "controls": [
          "DataGrid: 6 colonnes x 4 lignes (Cash, Cartes, Cheques, Produits, OD, Devises)",
          "Ligne 1: Solde ouverture (readonly)",
          "Ligne 2: Montant compte (editable via bouton Saisie)",
          "Ligne 3: Montant calcule (readonly)",
          "Ligne 4: Ecart (calculated, highlight if != 0)",
          "Button: Saisie (ouvre IDE 120)",
          "Button: Apport coffre (ouvre IDE 123)",
          "Button: Apport articles (ouvre IDE 124)",
          "Button: Remise (ouvre IDE 125)",
          "Button: Ecart (ouvre IDE 130, enabled if ecart exists)",
          "Button: Valider (enabled if all controls pass)",
          "TextField: Solde final (calculated, readonly)",
          "TextField: Total versement coffre (calculated, readonly)"
        ]
      },
      {
        "name": "validation",
        "controls": [
          "Alert: Tous les moyens pointes? (check icon if tousPointes)",
          "Alert: Tous les ecarts justifies? (check icon if !ecartsDetectes OR ecartsJustifies)",
          "Button: Valider fermeture (primary, enabled if all checks pass)"
        ]
      },
      {
        "name": "tickets",
        "controls": [
          "Button: Generer tickets (enabled if fermetureValidee)",
          "List: Tickets generes (IDE 138, IDE 136, IDE 154)"
        ]
      },
      {
        "name": "detail-devises",
        "controls": [
          "DataGrid: Detail des devises comptees (readonly)",
          "Columns: Code devise, Libelle, Montant ouverture, Montant compte, Montant calcule, Ecart"
        ]
      }
    ]
  },
  "mockData": {
    "count": 3,
    "description": "3 sessions de fermeture: 1 session sans ecart, 1 session avec ecart justifie, 1 session avec ecart non justifie. Chaque session a 6 moyens de paiement (Cash, Cartes, Cheques, Produits, OD, Devises) avec des montants realistes. Inclure des apports coffre et remises pour tester les calculs de solde final."
  },
  "dependencies": {
    "stores": [
      "useSessionStore (pour societe, numeroSession)",
      "useFermetureCaisseStore (pour recap, pointages, etat validation)"
    ],
    "sharedTypes": [
      "PointageDevise",
      "PointageArticle",
      "PointageApproRemise",
      "MoyenPaiement",
      "RecapFermeture"
    ],
    "externalApis": [
      "IDE 120 - Saisie contenu caisse",
      "IDE 123 - Apport coffre",
      "IDE 124 - Apport articles",
      "IDE 125 - Remise en caisse",
      "IDE 130 - Ecart fermeture caisse",
      "IDE 133 - Mise a jour comptage caisse WS",
      "IDE 134 - MAJ detail session WS",
      "IDE 136 - Generation ticket WS",
      "IDE 138 - Ticket fermeture session",
      "IDE 154 - Tableau recap fermeture",
      "IDE 155 - Controle fermeture caisse WS"
    ]
  }
}

SPEC EXCERPT (business rules):
﻿# ADH IDE 131 - Fermeture caisse

> **Analyse**: Phases 1-4 2026-02-07 03:50 -> 03:08 (23h18min) | Assemblage 03:08
> **Pipeline**: V7.2 Enrichi
> **Structure**: 4 onglets (Resume | Ecrans | Donnees | Connexions)

<!-- TAB:Resume -->

## 1. FICHE D'IDENTITE

| Attribut | Valeur |
|----------|--------|
| Projet | ADH |
| IDE Position | 131 |
| Nom Programme | Fermeture caisse |
| Fichier source | `Prg_131.xml` |
| Dossier IDE | Caisse |
| Taches | 22 (5 ecrans visibles) |
| Tables modifiees | 3 |
| Programmes appeles | 20 |
| Complexite | **BASSE** (score 35/100) |

## 2. DESCRIPTION FONCTIONNELLE

### 2.1 Objectif metier

**Fermeture caisse** cloture une session de caisse en comparant les montants COMPTES physiquement par le caissier aux montants CALCULES theoriquement par le systeme. Le processus:

1. **Affiche un tableau recapitulatif** avec 6 colonnes de moyens de paiement (Cash, Cartes, Cheques, Produits, OD, Devises)
2. **Compare 4 lignes de valeurs** pour chaque moyen:
   - Solde ouverture (montant initial)
   - Montant compte (saisi par le caissier)
   - Montant calcule (theorique systeme)
   - Ecart (difference compte - calcule)
3. **Detecte les ecarts** et oblige le caissier a les justifier via commentaire
4. **Calcule le solde final** = Montant compte - Versement au coffre
5. **Genere les tickets de fermeture** (fermeture session, remises/appros, tableau recap)
6. **Met a jour l'historique** dans les tables pointage_*

### 2.2 Flux utilisateur principal

```
DEBUT
  |
  v
[Affichage ecran principal 131.1]
  - Tableau 6 colonnes x 4 lignes
  - Boutons: Saisie, Apport coffre, Apport articles, Remise, Ecart, Valider
  |
  v
[Caissier saisit les montants comptes]
  -> Appelle IDE 120 (Saisie contenu caisse)
  |
  v
[Systeme calcule ecarts]
  Ecart = Montant_compte - Montant_calcule
  |
  +-- Si Ecart <> 0 --> [Justification obligatoire]
  |                      -> Appelle IDE 130 (Ecart fermeture caisse)
  |                      -> Saisie commentaire ecart
  v
[Caissier effectue versement au coffre]
  -> Appelle IDE 123 (Apport coffre)
  -> Appelle IDE 125 (Remise en caisse)
  |
  v
[Validation fermeture - IDE 155]
  - Controle: tous les moyens ont ete pointes
  - Controle: ecarts justifies si existants
  |
  v
[Generation tickets]
  -> IDE 138 (Ticket fermeture session)
  -> IDE 136 (Generation ticket WS) pour remises/appros
  -> IDE 154 (Tableau recap fermeture)
  |
  v
[Mise a jour tables historique]
  -> IDE 134 (MAJ detail session WS)
  -> pointage_devise, pointage_article, pointage_appro_remise
  |
  v
FIN
```

### 2.3 Acces au programme

Appele depuis:
- [Gestion caisse (IDE 121)](ADH-IDE-121.md) - Mode standard
- [Gestion caisse 142 (IDE 298)](ADH-IDE-298.md) - Mode 142

### 2.4 Donnees modifiees

| Table | Role | Operations |
|-------|------|------------|
| pointage_devise | Enregistre les comptages par devise | WRITE - Maj montants et ecarts |
| pointage_article | Enregistre les comptages produits | WRITE - Maj stocks produits |
| pointage_appro_remise | Enregistre les mouvements coffre | WRITE - Flag edition ticket |

<details>
<summary>Detail : phases du traitement</summary>

#### Phase 1 : Traitement (19 taches)

- **131** - Fermeture caisse
- **131.1** - Fermeture caisse **[[ECRAN]](#ecran-t2)**
- **131.1.1** - (sans nom) **[[ECRAN]](#ecran-t3)**
- **131.1.2** - (sans nom) **[[ECRAN]](#ecran-t7)**
- **131.1.2.1** - Devises finales
- **131.1.2.1.1** - Devises finales
- **131.1.2.1.2** - Devises finales
- **131.1.2.2** - Update AppRem
- **131.1.2.2.1** - Update devises
- **131.1.2.2.2** - Update produits
- **131.1.3** - (sans nom) **[[ECRAN]](#ecran-t14)**
- **131.1.3.1** - Devises finales
- **131.1.3.1.1** - Devises finales
- **131.1.3.1.2** - Devises finales
- **131.1.3.2** - Update AppRem
- **131.1.3.2.1** - Update devises
- **131.1.3.2.2** - Update produits
- **131.1.4** - Detail devises **[[ECRAN]](#ecran-t21)**
- **131.1.4.1** - Detail devises **[[ECRAN]](#ecran-t22)**

Delegue a : [Mise à jour detail session WS (IDE 134)](ADH-IDE-134.md), [Devise update session WS (IDE 142)](ADH-IDE-142.md), [Devises finales F/F Nbre WS (IDE 144)](ADH-IDE-144.md), [Devises finales F/F Qte WS (IDE 145)](ADH-IDE-145.md), [Generation tableau recap WS (IDE 135)](ADH-IDE-135.md), [Devises tableau recap WS (IDE 146)](ADH-IDE-146.md), [Tableau recap fermeture (IDE 154)](ADH-IDE-154.md), [Recuperation du titre (IDE 43)](ADH-IDE-43.md), [Apport coffre (IDE 123)](ADH-IDE-123.md), [Apport articles (IDE 124)](ADH-IDE-124.md), [Remise en caisse (IDE 125)](ADH-IDE-125.md), [Ecart fermeture caisse (IDE 130)](ADH-IDE-130.md)

#### Phase 2 : Initialisation (1 tache)

- **131.1.1.1** - raz

Delegue a : [Devises RAZ WS (IDE 148)](ADH-IDE-148.md)

#### Phase 3 : Validation (1 tache)

- **131.1.1.2** - Validation

Delegue a : [Controle fermeture caisse WS (IDE 155)](ADH-IDE-155.md)

#### Phase 4 : Calcul (1 tache)

- **131.1.1.3** - Maj devises comptees

Delegue a : [Mise a jour comptage caisse WS (IDE 133)](ADH-IDE-133.md), [Calcul solde ouverture WS (IDE 127)](ADH-IDE-127.md)

#### Tables impactees

| Table | Operations | Role metier |
|-------|-----------|-------------|
| pointage_devise | **W** (2 usages) | Devises / taux de change |
| pointage_article | **W** (2 usages) | Articles et stock |
| pointage_appro_remise | **W** (2 usages) |  |

</details>

## 3. BLOCS FONCTIONNELS

### 3.1 Traitement (19 taches)

Traitements internes.

---

#### <a id="t1"></a>131 - Fermeture caisse

**Role** : Tache d'orchestration : point d'entree du programme (19 sous-taches). Coordonne l'enchainement des traitements.

<details>
<summary>18 sous-taches directes</summary>

| Tache | Nom | Bloc |
|-------|-----|------|
| [131.1](#t2) | Fermeture caisse **[[ECRAN]](#ecran-t2)** | Traitement |
| [131.1.1](#t3) | (sans nom) **[[ECRAN]](#ecran-t3)** | Traitement |
| [131.1.2](#t7) | (sans nom) **[[ECRAN]](#ecran-t7)** | Traitement |
| [131.1.2.1](#t8) | Devises finales | Traitement |
| [131.1.2.1.1](#t9) | Devises fina

REFERENCE PATTERN (follow this exact structure):
```typescript
import { create } from 'zustand';
import type {
  ExtraitAccountInfo,
  ExtraitTransaction,
  ExtraitSummary,
  ExtraitPrintFormat,
} from '@/types/extrait';
import { extraitApi } from '@/services/api/endpoints-lot3';
import { useDataSourceStore } from './dataSourceStore';

interface ExtraitState {
  selectedAccount: ExtraitAccountInfo | null;
  transactions: ExtraitTransaction[];
  summary: ExtraitSummary | null;
  searchResults: ExtraitAccountInfo[];
  isSearching: boolean;
  isLoadingExtrait: boolean;
  isPrinting: boolean;
  error: string | null;
}

interface ExtraitActions {
  searchAccount: (societe: string, query: string) => Promise<void>;
  selectAccount: (account: ExtraitAccountInfo) => void;
  loadExtrait: (
    societe: string,
    codeAdherent: number,
    filiation: number,
    dateDebut?: string,
    dateFin?: string,
  ) => Promise<void>;
  printExtrait: (
    societe: string,
    codeAdherent: number,
    filiation: number,
    format: ExtraitPrintFormat,
  ) => Promise<void>;
  reset: () => void;
}

type ExtraitStore = ExtraitState & ExtraitActions;

const MOCK_ACCOUNTS: ExtraitAccountInfo[] = [
  { societe: 'SOC1', codeAdherent: 1001, filiation: 0, nom: 'DUPONT', prenom: 'Jean', statut: 'normal', hasGiftPass: false },
  { societe: 'SOC1', codeAdherent: 1002, filiation: 0, nom: 'MARTIN', prenom: 'Sophie', statut: 'normal', hasGiftPass: true },
  { societe: 'SOC1', codeAdherent: 1003, filiation: 1, nom: 'DURAND', prenom: 'Pierre', statut: 'bloque', hasGiftPass: false },
];

const MOCK_TRANSACTIONS: ExtraitTransaction[] = [
  { id: 1, date: '2026-02-10', heure: '09:15', libelle: 'Achat boutique', debit: 45.50, credit: 0, solde: -45.50, codeService: 'BTQ', codeImputation: 'IMP01', giftPassFlag: false, nbArticles: 3, status: 'debit', numeroPiece: 'VTE-001', modePaiement: 'CB', caissier: 'MARTIN S.' },
  { id: 2, date: '2026-02-10', heure: '14:30', libelle: 'Credit compte', debit: 0, credit: 200, solde: 154.50, codeService: 'CAI', codeImputation: 'IMP02', giftPassFlag: false, status: 'credit', numeroPiece: 'CRD-042', modePaiement: 'Especes', caissier: 'DUPONT J.' },
  { id: 3, date: '2026-02-09', heure: '12:45', libelle: 'Repas restaurant', libelleSupplementaire: 'Menu du jour', debit: 32.00, credit: 0, solde: 122.50, codeService: 'RST', codeImputation: 'IMP03', giftPassFlag: true, nbArticles: 1, status: 'debit', numeroPiece: 'RST-117', modePaiement: 'GiftPass', caissier: 'MARTIN S.' },
  { id: 4, date: '2026-02-08', heure: '16:00', libelle: 'Annulation vente', debit: 0, credit: 15.00, solde: 154.50, codeService: 'BTQ', codeImputation: 'IMP01', giftPassFlag: false, status: 'annule', numeroPiece: 'ANN-003', modePaiement: 'CB', caissier: 'DUPONT J.', commentaire: 'Erreur de saisie' },
  { id: 5, date: '2026-02-08', heure: '10:20', libelle: 'Regularisation solde', debit: 0, credit: 5.00, solde: 139.50, codeService: 'CAI', codeImputation: 'IMP02', giftPassFlag: false, status: 'regularise', numeroPiece: 'REG-007', modePaiement: 'Interne', caissier: 'ADMIN' },
];

const MOCK_SUMMARY: ExtraitSummary = {
  totalDebit: 77.50,
  totalCredit: 220,
  soldeActuel: 142.50,
  nbTransactions: 5,
};

const initialState: ExtraitState = {
  selectedAccount: null,
  transactions: [],
  summary: null,
  searchResults: [],
  isSearching: false,
  isLoadingExtrait: false,
  isPrinting: false,
  error: null,
};

export const useExtraitStore = create<ExtraitStore>()((set) => ({
  ...initialState,

  searchAccount: async (societe, query) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isSearching: true, error: null });

    if (!isRealApi) {
      const filtered = MOCK_ACCOUNTS.filter(
        (a) =>
          a.nom.toLowerCase().includes(query.toLowerCase()) ||
          a.prenom.toLowerCase().includes(query.toLowerCase()) ||
          String(a.codeAdherent).includes(query),
      );
      set({ searchResults: filtered, isSearching: false });
      return;
    }

    try {
      const response = await extraitApi.searchAccount(societe, query);
      set({ searchResults: response.data.data ?? [] });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur recherche compte';
      set({ searchResults: [], error: message });
    } finally {
      set({ isSearching: false });
    }
  },

  selectAccount: (account) => {
    set({ selectedAccount: account, transactions: [], summary: null, error: null });
  },

  loadExtrait: async (societe, codeAdherent, filiation, dateDebut, dateFin) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isLoadingExtrait: true, error: null });

    if (!isRealApi) {
      set({
        transactions: MOCK_TRANSACTIONS,
        summary: MOCK_SUMMARY,
        isLoadingExtrait: false,
      });
      return;
    }

    try {
      const response = await extraitApi.getExtrait(
        societe,
        codeAdherent,
        filiation,
        dateDebut,
        dateFin,
      );
      const data = response.data.data;
      set({
        transactions: data?.transactions ?? [],
        summary: data?.summary ?? null,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur chargement extrait';
      set({ transactions: [], summary: null, error: message });
    } finally {
      set({ isLoadingExtrait: false });
    }
  },

  printExtrait: async (societe, codeAdherent, filiation, format) => {
    const { isRealApi } = useDataSourceStore.getState();
    set({ isPrinting: true, error: null });

    if (!isRealApi) {
      set({ isPrinting: false });
      return;
    }

    try {
      await extraitApi.printExtrait({
        societe,
        codeAdherent,
        filiation,
        format,
      });
    } catch (e: unknown) {
      const message = e instanceof Error ? e.message : 'Erreur impression';
      set({ error: message });
    } finally {
      set({ isPrinting: false });
    }
  },

  reset: () => set({ ...initialState }),
}));

```